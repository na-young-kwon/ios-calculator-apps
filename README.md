## 계산기

#### 🗓️ 프로젝트 기간: 2021.11.8 - 2021.11.19

#### 개인프로젝트


##  목차
 * [학습 키워드](#✏️-학습키워드)
 * [Step 1](#step-1)
    * [구현 내용](#1-1.-구현-내용)
    * [고민했던 점](#-1-2.-고민했던-점)
* [Step 2](#step-2)
    * [구현 내용](#-2-1.-구현-내용)
    * [고민했던 점](#-2-2.-고민했던-점)



## ✏️ 학습키워드
- Generics
- Protocol
- Unit test
- TDD
- UML
- Stack view
- Double Stack
- Queue
- 고차함수
---

# STEP 1
### 구현 내용
- Queue타입을 코드로 구현했습니다
- 큐를 구현하기 위해 어떤 자료구조를 쓰면 좋을지 고민했습니다 
- LinkedList를 구현해보려고 노력했으니 시간부족 + 이해력 부족으로 배열로 구현하게 됐습니다
- 다만 배열은 데이터의 추가, 삭제가 느리기때문에 DoubleStack으로 시간복잡도를 개선했습니다

---
### 고민했던 점
### ✔ 구조체 vs 클래스
CalculateItemQueue를 구조체와 클래스 중 어느것으로 만들지 고민했습니다. 
아래와같은 이유로 구조체로 구현했습니다
- 인스턴스를 여러개 만들고 한 군데에서 큐를 수정했을 때 원본값이 바뀌면 안된다
- 값타입을 써서 원본을 지키고 복사본을 수정해야 한다
- 참조 타입에 비해 시스템 리소스가 적게 들어간다
- 상속이 필요하지 않다  

<br>

### ✔ 제네릭을 사용한 이유
- 계산기 프로젝트에서는 큐에 Double, Operator 타입이 들어올 수 있다고 생각했습니다
- 이때 각각의 타입에 대해서 CalculateItemQueue를 구현한다면 같은 코드가 중복됩니다
- 따라서 특정 타입을 염두해서 Queue를 구현하는 것이 아닌 제네릭을 사용하여 확장성있는 타입을 구현했습니다


>장점
- 재사용하기도 쉽고 코드의 중복을 줄일 수 있다
- 어떤 타입에도 유연하게 대응할 수 있게된다
```swift
struct CalculateItemQueue<T: CalculateItem> { code.. }
```
<br>

### ✔ 더블스택
- 시간복잡도문제를 해결하기 위해 배열을 두개 사용했습니다.
- removeFirst() 메서드 사용시 요소가 삭제되면서 뒤에있는 요소들이 앞으로 한칸씩 이동하기 때문에 시간복잡도가 O(n) 입니다. 
- 이를 개선하기 위해 reversed() + removeLast() 조합으로 큐를 구현했습니다  
*(참고로 reversed와 removeLast 메서드 모두 시간복잡도는 O(1)입니다.)

<br>

### ✔ TDD의 장점과 단점

|장점|단점|
|:---:|:---:|
|개발자가 의도한 대로 코드가 동작하는지 확인할 수 있다|테스트코드를 만드는데 시간이 많이 걸린다|
|프로그램 내의 버그를 찾아내고 코드의 퀄리티를 높일 수 있다|private한 메서드나 프로퍼티는 어떻게 테스트를 해야할지 아직 잘 모르겠다|


- 프로젝트를 TDD기반으로 진행해보려고 했으나 익숙하지 않았던 탓인지 점점 테스트코드보단 본코드를 먼저 작성하곤 했습니다

<br>

### ✔ 오버스펙에 관한 피드백
> 앞으로 필요할만한 것을 예상하여 구현하는 것도 좋지만, 빠르게 당장 필요한 기능만을 구현해야하는 상황에서는 오버스펙이 될 수도 있고 나중의 요구사항이 현재 내가 예상한 것과 달라졌을 때에는 구현한 사항을 롤백하고 다시 만들어야하기 때문에 같은 작업을 두번하게될 수도 있습니다.
가능한 당장 필요한 기능만 작게작게 구현하시는 습관을 들이는걸 추천합니다 

이런 피드백을 받았습니다. 
- 코드를 작성할 때 확장가능성에 대해 생각하고 미래에 일이 일어날일에 대비해야 한다고 생각했는데, 항상 그런것만은 아닌것 같습니다. 
- 실제로 스텝1에서 오버스펙인것 같다고 피드백 받은 부분을 스텝2,3에서 롤백하는 일이 발생했습니다. 같은 작업을 두 번 하게된것이죠. 
- 따라서 확장가능성과 기획을 변동에 대응할 수 있는 코드를 작성하는것과, 당장 필요한 기능만 구현하는것의 발란스를 잘 맞춰야할 것 같습니다. (하지만 이게 가능은 할까요? 너무 어려워요...)


---

# STEP 2
### 구현 내용
|타입|설명|메서드|
|:---:|:---|:---|
|`String Extension`|문자열을 연산자를 기준으로 나눈 후 배열에 담아 [String] 을 반환합니다|split(with:)|
|`ExpressionParser`|전역메서드를 모아놓은 열거형입니다|parse(from:), componentsByOperators(from:)|
|`Formula`|formula는 하나의 수식을 뜻합니다.  피연산자는 operands 큐, 연산자는 operators 큐의 enqueueStack에 담깁니다|result()
|`Operator`|연산자를 정의한 타입입니다|- calculate(lhs: rhs:) |


---
### 고민했던 점
### ✔ 빼기연산자와 음수를 구분하는 방법
- "⁺⁄₋ 버튼을 눌렀을 때 현재 입력된 숫자의 부호를 변환한다" 라는 조건이 있기 때문에 5 - (-5) 같은 상황이 나올 수 있습니다
- 이 둘을 구분해주기 위해 빼기연산자는 _(언더스코어)로 바꿔주었습니다.

<br>

### ✔ UML에 대해 이해
- UML에서 타입 프로퍼티/메서드는 밑줄로 표현해준다는것을 알았습니다
- `private static` 처럼 private 레벨 + 타입메서드 를 처음 봤습니다
- 인스턴스를 생성하지 않고 메서드가 밖으로 노출될 필요가 없다면 이같은 접근제어를 붙여줄 수 있습니다
<img width="282" alt="스크린샷 2021-11-20 오후 11 27 18" src="https://user-images.githubusercontent.com/74536728/142729944-3ef47bac-7e8e-4b5e-ac1e-81847da77ca2.png">

<br>

### ✔ 왜 빈 프로토콜을 선언했는가?
- `CalculateItem` 프로토콜을 만든 이유는 해당 프로토콜을 준수하는 타입만 Queue에 들어올 수 있도록 하려는 의도로 해석했습니다
- Queue에는 연산자, 피연산자가 모두 들어올 수 있도록 제네릭을 이용해서 유연하게 작성하고 코드의 중복을 줄입니다
- 대신 Double과 Operator타입이 해당 프로토콜을 준수함으로서 프로토콜의 하나의 타입으로 사용했다고 할 수 있습니다
- 정리하자면 제네릭 타입을 특정 프로토콜을 따르는 타입만 사용할 수 있도록 제약을 두기위해 프로토콜을 만들었습니다.
>빈 프로토콜과 프로토콜을 채택한 모습
```swift
protocol CalculateItem { }

extension Double: CalculateItem { }
enum Operator: Character, CaseIterable, CalculateItem { }
```
